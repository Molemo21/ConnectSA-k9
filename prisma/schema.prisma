// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["metrics"]
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

enum UserRole {
  CLIENT
  PROVIDER
  ADMIN
}

enum ProviderStatus {
  PENDING
  APPROVED
  REJECTED
  SUSPENDED
  INCOMPLETE
}

enum PaymentMethod {
  ONLINE
  CASH
}

enum BookingStatus {
  PENDING
  CONFIRMED
  IN_PROGRESS
  AWAITING_CONFIRMATION
  COMPLETED
  CANCELLED
  PENDING_EXECUTION
  PAYMENT_PROCESSING
  DISPUTED
}

enum PaymentStatus {
  PENDING
  ESCROW
  HELD_IN_ESCROW
  PROCESSING_RELEASE
  RELEASED
  REFUNDED
  FAILED
  COMPLETED
  CASH_PENDING
  CASH_PAID
  CASH_RECEIVED
  CASH_VERIFIED
}

enum PayoutStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

model User {
  id            String   @id @default(cuid())
  email         String   @unique
  name          String
  password      String?
  phone         String?
  avatar        String?
  role          UserRole @default(CLIENT)
  emailVerified Boolean  @default(false)
  isActive      Boolean  @default(true)
  deletedAt     DateTime? // Tombstone flag for anonymized users
  googleId      String?  @unique
  appleId       String?  @unique
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  provider            Provider?
  bookings            Booking[]            @relation("ClientBookings")
  adminReviews        ProviderReview[]
  verificationTokens  VerificationToken[]
  passwordResetTokens PasswordResetToken[]
  bookingDrafts       BookingDraft[]
  notifications       Notification[]
  pushSubscriptions   PushSubscription[]

  @@index([deletedAt]) // Index for efficient filtering
  @@map("users")
}

model Provider {
  id             String         @id @default(cuid())
  userId         String         @unique
  user           User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  businessName   String?
  description    String?
  experience     Int?
  hourlyRate     Float?
  location       String?
  idDocument     String?
  proofOfAddress String?
  certifications String[]
  profileImages  String[]
  status         ProviderStatus @default(PENDING)
  available      Boolean        @default(true)
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt

  // Catalogue setup tracking fields
  catalogueSetupCompleted   Boolean   @default(false)
  catalogueSetupCompletedAt DateTime?

  // Bank details fields
  bankName      String?
  bankCode      String?
  accountNumber String?
  accountName   String?
  recipientCode String? @map("recipient_code")

  // Relations
  bookings       Booking[]         @relation("ProviderBookings")
  services       ProviderService[]
  catalogueItems CatalogueItem[] // New relation for catalogue items
  reviews        Review[]
  adminReviews   ProviderReview[]
  bookingDrafts  BookingDraft[]
  payouts        Payout[]

  @@map("providers")
}

model Service {
  id          String   @id @default(cuid())
  name        String
  description String?
  categoryId  String
  basePrice   Float?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  bookings       Booking[]
  providers      ProviderService[]
  catalogueItems CatalogueItem[] // New relation for catalogue items
  category       ServiceCategory   @relation(fields: [categoryId], references: [id])
  bookingDrafts  BookingDraft[]

  @@map("services")
}

model ServiceCategory {
  id          String   @id @default(cuid())
  name        String
  description String?
  icon        String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  services Service[]

  @@map("service_categories")
}

model Booking {
  id            String        @id @default(cuid())
  clientId      String
  providerId    String
  serviceId     String
  scheduledDate DateTime
  duration      Int
  totalAmount   Float
  platformFee   Float
  description   String?
  address       String
  status        BookingStatus @default(PENDING)
  paymentMethod PaymentMethod @default(ONLINE)
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  // New catalogue-based pricing fields (nullable for backward compatibility)
  catalogueItemId    String? // Nullable for backward compatibility
  bookedPrice        Float? // Snapshot of catalogue item price
  bookedCurrency     String? // Snapshot of catalogue item currency
  bookedDurationMins Int? // Snapshot of catalogue item duration

  // Relations
  client        User           @relation("ClientBookings", fields: [clientId], references: [id], onDelete: Restrict)
  provider      Provider       @relation("ProviderBookings", fields: [providerId], references: [id], onDelete: Restrict)
  service       Service        @relation(fields: [serviceId], references: [id], onDelete: Restrict)
  catalogueItem CatalogueItem? @relation(fields: [catalogueItemId], references: [id], onDelete: SetNull)
  payment       Payment?
  review        Review?

  @@map("bookings")
}

model Payment {
  id          String        @id @default(cuid())
  bookingId   String        @unique
  amount      Float
  paystackRef String        @unique
  status      PaymentStatus
  paidAt      DateTime?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  // Additional fields from production database
  escrowAmount     Float?  @map("escrow_amount")
  platformFee      Float?  @map("platform_fee")
  transactionId    String? @map("transaction_id")
  authorizationUrl String? @map("authorization_url")
  accessCode       String? @map("access_code")
  currency         String?
  errorMessage     String? @map("error_message")
  providerResponse Json?   @map("provider_response")
  userId           String? @map("user_id")

  // Relations
  booking Booking @relation(fields: [bookingId], references: [id], onDelete: Restrict)
  payout  Payout?

  @@map("payments")
}

model Review {
  id         String   @id @default(cuid())
  bookingId  String   @unique
  providerId String
  rating     Int
  comment    String?
  createdAt  DateTime @default(now())

  // Relations
  booking  Booking  @relation(fields: [bookingId], references: [id], onDelete: Restrict)
  provider Provider @relation(fields: [providerId], references: [id], onDelete: Restrict)

  @@map("reviews")
}

model ProviderService {
  id         String @id @default(cuid())
  providerId String
  serviceId  String
  customRate Float?

  // Relations
  provider Provider @relation(fields: [providerId], references: [id], onDelete: Cascade)
  service  Service  @relation(fields: [serviceId], references: [id], onDelete: Cascade)

  @@unique([providerId, serviceId])
  @@map("provider_services")
}

model ProviderReview {
  id         String         @id @default(cuid())
  providerId String
  adminId    String
  comment    String
  status     ProviderStatus
  createdAt  DateTime       @default(now())

  // Relations
  provider Provider @relation(fields: [providerId], references: [id], onDelete: Cascade)
  admin    User     @relation(fields: [adminId], references: [id], onDelete: Cascade)

  @@map("ProviderReview")
}

model VerificationToken {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expires   DateTime
  createdAt DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("VerificationToken")
}

model PasswordResetToken {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expires   DateTime
  createdAt DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("PasswordResetToken")
}

model BookingDraft {
  id            String    @id @default(cuid())
  userId        String
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  serviceId     String?
  service       Service?  @relation(fields: [serviceId], references: [id], onDelete: SetNull)
  providerId    String?
  provider      Provider? @relation(fields: [providerId], references: [id], onDelete: SetNull)
  scheduledDate DateTime?
  duration      Int?
  totalAmount   Float?
  address       String?
  description   String?
  status        String    @default("DRAFT")
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@map("booking_drafts")
}

model Notification {
  id        String   @id @default(cuid())
  userId    String
  type      String
  title     String
  message   String
  isRead    Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notifications")
}

model PushSubscription {
  id        String   @id @default(cuid())
  userId    String
  endpoint  String   @unique
  p256dh    String
  auth      String
  userAgent String?
  createdAt DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("push_subscriptions")
}

// New CatalogueItem model for catalogue-based pricing
model CatalogueItem {
  id           String   @id @default(cuid())
  providerId   String
  serviceId    String
  title        String
  shortDesc    String
  longDesc     String?
  price        Float
  currency     String   @default("ZAR")
  durationMins Int
  images       String[] // Array of image URLs
  featuredImageIndex Int? // Index of featured image (0-based), null = use first image
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  provider Provider  @relation(fields: [providerId], references: [id], onDelete: Cascade)
  service  Service   @relation(fields: [serviceId], references: [id], onDelete: Cascade)
  bookings Booking[]

  @@map("catalogue_items")
}

model Payout {
  id           String       @id @default(cuid())
  paymentId    String       @unique
  providerId   String
  amount       Float
  paystackRef  String       @map("paystack_ref")
  status       PayoutStatus @default(PENDING)
  transferCode String?      @map("transfer_code")
  recipientCode String?     @map("recipient_code")
  error        String?
  createdAt    DateTime     @default(now()) @map("created_at")
  updatedAt    DateTime     @updatedAt @map("updated_at")

  // Relations
  payment  Payment  @relation(fields: [paymentId], references: [id], onDelete: Restrict)
  provider Provider @relation(fields: [providerId], references: [id], onDelete: Restrict)

  @@map("payouts")
}

model WebhookEvent {
  id         String    @id @default(cuid())
  eventType  String    @map("event_type")
  paystackRef String   @map("paystack_ref")
  payload    String    // JSON string of full webhook payload
  processed  Boolean   @default(false)
  retryCount Int       @default(0) @map("retry_count")
  error      String?
  createdAt  DateTime  @default(now()) @map("created_at")
  processedAt DateTime? @map("processed_at")

  @@index([eventType, paystackRef, processed])
  @@index([processed, createdAt])
  @@map("webhook_events")
}

// ============================================================================
// ENVIRONMENT FINGERPRINTING - CRITICAL SAFETY TABLE
// ============================================================================
// This table stores the environment fingerprint to prevent misconfiguration.
// It MUST exist in every database and MUST match the expected environment.
// Validation happens BEFORE Prisma client initialization.
// ============================================================================

model DatabaseMetadata {
  id          String   @id @default("singleton")
  environment String   // "dev" | "staging" | "prod" - MUST match expected
  fingerprint String   // Additional verification string
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("database_metadata")
}
